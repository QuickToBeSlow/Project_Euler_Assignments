import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Random;

/**
 * References:
 * 1. https://andrew.gibiansky.com/blog/physics/lattice-boltzmann-method/ (link to Andrew Gibiansky's blog post)
 * 2. https://github.com/gibiansky/experiments/tree/master/lbm (link to Andrew Gibiansky's Python project)
 * 3. https://en.wikipedia.org/wiki/Lattice_Boltzmann_methods (Wikipedia article that helped me understand the basics of how the Lattice Boltzmann Method works)
 * 4. https://medium.com/swlh/create-your-own-lattice-boltzmann-simulation-with-python-8759e8b53b1c (helped a bit initially,
 *    but the code was far too high-leveled/done by libraries to be of much use)
 *
 * NOTE: Andrew Gibiansky helped tremendously in terms of both understanding how the Lattice Boltzmann Method works and
 *       how to implement it in programming form. The project would have been much more difficult without this,
 *       as most of the mathematics aren't even covered in Calculus II. Some of this content is from Calculus III I believe or
 *       perhaps other courses, not to mention the content and concepts from physics, such as dot products.
 *
 * @Author Blake Meyer
 * @Date 4/21/2021
 * @Simple_Description Uses the Lattice Boltzmann method to simulate the flow of a liquid.
 * @Summary
 * This project is used to show the implementation of the Lattice Boltzmann method, an algorithm that is
 * used to calculate the flow of fluids of both Newtonian and non-Newtonian nature. In this case,
 * the implementation is within two dimensions, although a three dimensional implementation is certainly possible.
 * Using this method, the program simulates the disturbance caused by a high concentration of fluid being placed within
 * a lower concentration of fluid, as well as the effects of the fluid flowing sideways.
 *
 * Ideally, this program may be used to study how fluid flows in a variety of different conditions, such as
 * how fluid interacts when flowing past a cylinder or a rectangle, or how two waves interact with each other.
 * In some conditions, such as those generated by fluid flowing past a cylinder, vortexes would generate and
 * demonstrate the phenomenon called "vortex shedding." This process occurs in nature as well, but
 * some fluid simulations fail to replicate this effect. Because of this, this method of fluid simulation
 * is one of the more accurate methods out there. Unfortunately, I have ran out of time to allow user input to
 * allow the testing of these effects, but it could be implemented by modifying the boundary conditions and
 * removing cells within boundaries (doing so causes issues).
 *
 * Additions I would make:
 * One of the most glaring problems with my program is what occurs when the difference between densities of the fluid
 * of neighboring cells becomes too great and too much fluid is distributed to neighboring cells. This results in
 * said cell to have a negative density, and this completely jacks up the simulation. I have reviewed my own code
 * what seems to be over 10 times trying to find where this problem would arise, but I cannot find an issue in
 * my implementation of the Lattice Boltzmann method. I would also add a user interface to allow easier modification
 * of boundaries for where the fluid cannot travel. This would allow the testing of vortex shedding and the like,
 * which is very important to any practical use of the tool (this is touched on more in Marketability).
 *
 * Marketability:
 * This tool, while interesting, fails to be of much practical use, especially considering the bug mentioned
 * in the previous section. Additionally, there is no editor the user may use to adjust boundaries or the like,
 * making it essentially just a fancy effect and nothing more. With some additions to the program,
 * it would be an interesting tool, and could have some real-world applications such as measuring shear stress
 * on buildings with a few more modifications after that (okay, maybe a lot more modifications). Regardless,
 * the program obviously has little to offer in its current form, and more work needs to be done to make
 * a serviceable application.
 *
 * How it works: (I essentially started writing this because I forgot the exact requirements of the summary and checked back on it later. I decided to just leave it in though.)
 * The Lattice Boltzmann method can be simplified to two steps, the streaming step and the collision step.
 * Starting off with the collision step since it is the easiest to understand, when fluid collides with the edges
 * of the screen, the fluid must bounce off of it like waves in a pool would. To do this,
 * once fluid reaches a given wall, the velocity (either in the x or y direction) that results in the
 * fluid approaching the wall is flipped, thus making it appear as though the fluid bounced off the wall.
 * Additionally, the collision step must calculate velocity changes for individual molecules due to these collisions.
 * To simplify this process, the Bhatnagar-Gross-Krook (BGK) model assumes that all of the fluid
 * approaches equilibrium every time step. Over time, higher concentrations of liquid will travel to lower concentrations,
 * and eventually the concentrations of the fluid would become like that of a still pond.
 * Not only does this result in a simplified process, it is much more efficient as well.
 *
 * Moving onto the streaming step, essentially this moves the fluid from one cell to another every time step.
 * This process SOUNDS simple, but the mathematics required make the process difficult at best.
 * Due to the fact that most of the maths are beyond me, I will only provide how information about the fluid is stored.
 * As it was mentioned earlier, fluid moves from one cell to another in the streaming step, and for this to occur
 * there must be individual cells that hold information about the fluid. To accomplish this, cells are stored in a
 * two dimensional grid along the x and y axes. For each cell there is also a velocity in the x and y directions,
 * a density (concentration of fluid), the current directions the fluid will flow (dispersed to 8 neighboring cells),
 * the next directions will flow in the following time step, and an equilibrium calculation for the directions.
 */

public class FluidSimulation {
    final static double FRAME_RATE = 30;

    final static int xRes = 400;
    final static int yRes = 200;

    final static double speed = 1; //How fast the fluid moves. Essentially negated with the BGK method, but useful to understand the code.
    final static double TAU = 2; //Adjusts the viscosity of the fluid.

    //Hard-coded values necessary to determine impact of fluid shifts from certain directions (see Gibiansky's explanation of the BGK assumption).
    static double[] weights;

    static JFrame frame;
    static JPanel panel;

    //Stores densities of the fluid (also mass, but due to a fixed volume it's essentially the same thing. Could also be called fluid concentration).
    static double[][] densities;

    //Stores velocities of the fluid.
    static double[][][] velocities;

    //Stores where/how the fluid is traveling.
    static double[][][] directions;
    //Used to calculate how the fluid is traveling next.
    static double[][][] next_directions;

    //Used to keep the fluid in equilibrium.
    static double[][][] equilibrium;

    public static void main(String[] args) {
        makeGUI();
        setWeights();
        setDensities();
        setDirections();


        calcDensity(directions);
        calcVelocity(directions);
        calcEquilibrium();
        while (true) {
            step();
        }
    }

    public static void makeGUI() {
        frame = new JFrame("Fluid Simulation");
        panel = new JPanel();
        panel.setPreferredSize(new Dimension(xRes, yRes));
        frame.setSize(xRes+56,yRes+78);
        frame.setLocationRelativeTo(null);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        panel.setPreferredSize(new Dimension(frame.getWidth(),frame.getHeight()));
        frame.add(panel);
        frame.setVisible(true);
    }

    public static void setWeights() {
        //Weight values for each cell's connections to other cells
        weights = new double[]{1.0/36.0,1.0/9.0,1.0/36.0,1.0/9.0,4.0/9.0,1.0/9.0,1.0/36.0,1.0/9.0,1.0/36.0};
    }

    public static void setDensities() {
        Random r = new Random();
        densities = new double[yRes][xRes];
        velocities = new double[yRes][xRes][2];
        for (int i=0; i<densities.length; i++) {
            for (int j=0; j<densities[i].length; j++) {
                densities[i][j] = 0;

                velocities[i][j][0] = 0;
                velocities[i][j][1] = 0;
            }
        }
    }

    public static void setDirections() {
        directions = new double[yRes][xRes][9];
        next_directions = new double[yRes][xRes][9];
        equilibrium = new double[yRes][xRes][9];

        Random r = new Random();
        for (int i = 0; i<directions.length; i++) {
            for (int j = 0; j<directions[i].length; j++) {
                if (i<directions.length/2 && i>directions.length/3 && j<directions.length/2 && j>directions.length/3) {
                    directions[i][j][4] = 250;
                } else {
                    directions[i][j][4] = 50;
                }
            }
        }
    }

    public static void step() {
        //Shift all cells over 1 to make the liquid flow.
        for (int i=densities.length-1; i>0; i--) {
            for (int j=densities[i].length-1; j>0; j--) {
                densities[i][j] = densities[i][j-1];
                velocities[i][j] = velocities[i][j-1];

                for (int k=directions[i][j].length-1; k>0; k--) {
                    directions[i][j][k] = directions[i][j-1][k];
                }
            }
        }

        //Generate new fluid coming from the right.
        double position = Math.round(Math.random()*10)/10.0-0.5;

        Random r = new Random();
        for (int i=0; i<densities.length; i++) {
                densities[i][densities.length-1] = 50;
            for (int j=0; j<weights.length; j++) {
                if (i>densities.length*(4.5+position)/10.0 && i<densities.length*(5.5+position)/10.0) {
                    directions[i][0][j] = 150*weights[j];
                } else {
                    directions[i][0][j] = 50*weights[j]+r.nextDouble()*10;
                }
            }
        }

        //Calculate next fluid movements
        stream();

        //Calculate new densities, equilibrium, and velocities.
        calcDensity(next_directions);
        calcVelocity(next_directions);
        calcEquilibrium();
        calcVelocity(next_directions);

        //Update the directions for the next step.
        updateDirections();

        //Draw
        draw();
    }

    public static void draw() {
        try {
            Thread.sleep((long) (1000 / FRAME_RATE));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Graphics g = panel.getGraphics();
        BufferedImage BI = new BufferedImage(xRes, yRes, BufferedImage.TYPE_INT_RGB);

        panel.setBackground(Color.BLACK);
        for (int i = 0; i < yRes; i++) {
            for (int j = 0; j < xRes; j++) {
                int d1 = (int)Math.min(densities[i][j], 255);
                BI.setRGB(xRes-j-1, yRes-i-1, (d1/3 << 16 | d1/2 << 8 | d1));
            }
        }
        g.drawImage(BI, 20, 20, null);
    }

    public static void stream() {
        for (int y = 0; y < next_directions.length; y++) {
            for (int x = 0; x < next_directions[y].length; x++) {
                int z = 0;
                for (int i = -1; i <= 1; i++) {
                    for (int j = -1; j <= 1; j++) {
                        //Get neighboring fluid movements.
                        int xs = x + j;
                        int ys = y + i;

                        if (xs >= 0 && xs < next_directions[y].length && ys >= 0 && ys < next_directions.length) {
                            //Gets neighboring cells' incoming fluid.
                            next_directions[y][x][z] = directions[ys][xs][z];
                        } else {
                            //Explanation from Gibiansky:
                            //If the check yielded out of bounds, that means that the
                            //node we're computing for is on an edge. Thus, we should
                            //use bounce-back -- instead of getting the value from a nearby node,
                            //we get the value from itself.
                            int bounce_z = (1 - i) * 3 + (1 - j);
                            double friction_loss = 0.9;

                            //Fluid slows down from bouncing on walls.
                            next_directions[y][x][z] = friction_loss * directions[y][x][bounce_z];
                        }
                        z++;
                    }
                }
            }
        }
    }

    public static void calcDensity(double[][][] directions) {
        for (int y = 0; y < densities.length; y++) {
            for (int x = 0; x < densities[y].length; x++) {
                densities[y][x] = 0;

                for (int z = 0; z < 9; z++) {
                    //Calculate density based on surrounding cells.
                    densities[y][x] += directions[y][x][z];
                }
            }
        }
    }

    public static void calcVelocity(double[][][] directions) {
        for (int y = 0; y < velocities.length; y++) {
            for (int x = 0; x < velocities[y].length; x++) {
                velocities[y][x][0] = 0;
                velocities[y][x][1] = 0;

                int z = 0;
                for(int i = -1; i <= 1; i++) {
                    for(int j = -1; j <= 1; j++) {
                        velocities[y][x][0] += directions[y][x][z] * j;
                        velocities[y][x][1] += directions[y][x][z] * i;
                        z++;
                    }
                }

                //Change speed based on density (speed variable is used to adjust the speed).
                velocities[y][x][0] *= (densities[y][x] == 0) ? 0 : speed/densities[y][x];
                velocities[y][x][1] *= (densities[y][x] == 0) ? 0 : speed/densities[y][x];
            }
        }
    }

    public static void calcEquilibrium() {
        for (int y = 0; y < velocities.length; y++) {
            for (int x = 0; x < velocities[y].length; x++) {

                //Calculates the magnitude of the given force based on a cells' velocities.
                //velX^2 * velY^2 = velMag
                double velMag = velocities[y][x][0] * velocities[y][x][0] + velocities[y][x][1] * velocities[y][x][1];

                int z = 0;
                for (int i = -1; i <= 1; i++) {
                    for (int j = -1; j <= 1; j++) {

                        //Calculates the Dot Product for the x and y velocities.
                        //This helps determine the result of the Bhatnagar-Gross-Krook calculation.
                        double dotProd = j * velocities[y][x][0] + i * velocities[y][x][1];

                        //Implements the Bhatnagar-Gross-Krook assumption to slowly reach equilibrium.
                        double sum = 1.0;
                        sum += 3 / speed * dotProd;
                        sum += 4.5 / (speed * speed) * dotProd * dotProd;
                        sum -= 1.5 / (speed * speed) * velMag;

                        equilibrium[y][x][z] = weights[z] * densities[y][x] * sum;
                        z++;
                    }
                }
            }
        }
    }

    public static void updateDirections() {
        for (int y = 0; y < directions.length; y++) {
            for (int x = 0; x < directions[y].length; x++) {

                int z = 0;
                for (int i = -1; i <= 1; i++) {
                    for (int j = -1; j <= 1; j++) {

                        directions[y][x][z] = next_directions[y][x][z] - (next_directions[y][x][z] - equilibrium[y][x][z])/TAU;
                        z++;
                    }
                }

            }
        }
    }

}
